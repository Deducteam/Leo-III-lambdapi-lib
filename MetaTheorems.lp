/* Library on Meta-Theorems for Disjunctions and conjunctions
*/

require open Stdlib.List Stdlib.PropExt Stdlib.Disj;
  

////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////// lemmas ////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////


symbol insertBot : ğ•ƒ o â†’ â„• â†’ ğ•ƒ o;
rule insertBot â–¡ 0 â†ª (âŠ¥ â¸¬ â–¡)
with insertBot â–¡ (_ +1) â†ª â–¡
with insertBot ($l0 â¸¬ $l) 0 â†ª (âŠ¥ â¸¬ ($l0 â¸¬ $l))
with insertBot ($l0 â¸¬ $l) ($n +1) â†ª $l0 â¸¬ (insertBot $l $n);

symbol insertBots : ğ•ƒ o â†’ ğ•ƒ nat â†’ ğ•ƒ o;
rule insertBots $l â–¡ â†ª $l
with insertBots $l ($n â¸¬ $nl) â†ª insertBots (insertBot $l $n) $nl;

opaque symbol deleteBot (n : â„•) (c: ğ•ƒ o) :
Ï€ (disj (insertBot c n) = disj c)â‰”
begin
    induction
        {induction
            {reflexivity}
            {assume x xlist h0; 
            simplify; 
            rewrite disj_correct; 
            rewrite âŠ¥âˆ¨; 
            reflexivity}} 
        {assume n h0; 
        induction
            {reflexivity}
            {assume x c;
            simplify;
            assume h1;
            rewrite disj_correct;
            rewrite disj_correct;
            rewrite (h0 c);
            reflexivity}}
end;

opaque symbol deleteBots (n : ğ•ƒ nat) (c: ğ•ƒ o):
Ï€ (disj (insertBots c n) = disj c)â‰”
begin
    induction
        {induction
            {reflexivity}
            {assume x xlist h0; 
            reflexivity}}
        {induction
            {assume n h0 c; 
            simplify; 
            rewrite left deleteBot 0 c; 
            rewrite left h0 (insertBot c 0); 
            reflexivity}
            {assume n h0 nlist h1 c; 
            rewrite left (deleteBot (n +1) c); 
            rewrite left h1 (insertBot c (n +1)); 
            reflexivity;}}
end;

// transformation theorem //////////////////////////////////////////////////////
opaque symbol transform_n [l : Ï„ o] (c0 c1 c2: ğ•ƒ o): 
Ï€ (l â‡’ disj c1) â†’ Ï€ (disj (c0 ++ (l â¸¬ c2))) â†’ Ï€ (disj (c0 ++ c1 ++ c2)) â‰”
begin
    assume l c0 c1 c2 h2 h3;
    rewrite disj_++_correct;
    have H0: Ï€ ((disj c0) âˆ¨ disj (l â¸¬ c2))
        {rewrite left disj_++_correct; refine h3};
    refine âˆ¨â‚‘ H0 _ _
        {assume h4; refine âˆ¨áµ¢â‚ h4}
        {assume h4;
         have H1: Ï€ (l âˆ¨ disj c2)
            {rewrite left disj_correct; refine h4};
        rewrite disj_++_correct;
        refine âˆ¨â‚‘ H1 _ _
            {assume h5;
            refine âˆ¨áµ¢â‚‚ (âˆ¨áµ¢â‚ (h2 h5))}
            {assume h5;
            refine âˆ¨áµ¢â‚‚ (âˆ¨áµ¢â‚‚ h5)}}
end;






// new battlefield starting here

// first is acc
// symbol undup_acc : Î  [a : Set], (Ï„ a â†’ Ï„ a â†’ ğ”¹) â†’ ğ•ƒ a â†’ ğ•ƒ a â†’ ğ•ƒ a;

// rule undup_acc _ $acc â–¡ â†ª rev $acc
// with undup_acc $beq $acc ($x â¸¬ $l) â†ª
//   if (âˆˆ $beq $x $acc) (undup_acc $beq $acc $l) (undup_acc $beq ($x â¸¬ $acc) $l);

// opaque symbol mem_acc [a: Set] (beq : Ï„ a â†’ Ï„ a â†’ ğ”¹) l acc x: 
//     Ï€ (âˆˆ beq x acc) â†’ Ï€ (âˆˆ beq x (undup_acc beq acc l))â‰”
// begin
//     assume a beq;
//     induction
//         {simplify; admit
//         }
//         {assume x0 l0 h0 acc0 x1 h1; 
//         simplify undup_acc; 
//         refine âˆ¨â‚‘ (case_ğ”¹ (âˆˆ beq x0 acc0)) _ _ 
//             {assume h2; rewrite h2; simplify if; 
//             refine h0 acc0 x1 h1;
//             }
//             {assume h2; rewrite h2; simplify if; 
//             refine h0 (x0 â¸¬ acc0) x1 _;
//             refine mem_tail beq x1 x0 acc0 h1}}
// end;


// opaque symbol fdsfds [a: Set] (beq : Ï„ a â†’ Ï„ a â†’ ğ”¹) (beq_rfl : Î  x:Ï„ a, Ï€(beq x x)) l x: 
//     Ï€ (âˆˆ beq x (undup_acc beq â–¡ (x â¸¬ l))) â‰”
// begin
//     assume a beq beq_rfl;
//     induction
//         {assume x; simplify; refine beq_rfl x}
//         {assume x0 l0 h0 x1; 
//         simplify undup_acc; simplify;
//         refine âˆ¨â‚‘ (case_ğ”¹ (beq x0 x1)) _ _ 
//             {assume h1; rewrite h1; simplify if; 
//             refine mem_acc beq l0 (x1 â¸¬ â–¡) x1 _;
//             simplify; refine beq_rfl x1
//             }
//             {assume h1; rewrite h1; simplify if; 
//             refine mem_acc beq l0 (x0 â¸¬ (x1 â¸¬ â–¡)) x1 _;
//             simplify; refine oráµ¢â‚‚ (beq x1 x0) (beq_rfl x1)}}
// end;


