/* 
---------------------------------------------------------------------------
Library on Meta-Theorems for Disjunctions and Conjunctions
---------------------------------------------------------------------------

This file contains additions to the standard library file Disj.lp.
In particular, it encodes a theorem for removing âŠ¥ from clauses and an
n-ary version of the transformation theorem.
---------------------------------------------------------------------------
*/

require open Stdlib.Disj;

/******************************************************************************
*  Deletion of âŠ¥ 
******************************************************************************/

// Prelim 

symbol insertBot : ğ•ƒ o â†’ â„• â†’ ğ•ƒ o;
rule insertBot â–¡ 0 â†ª (âŠ¥ â¸¬ â–¡)
with insertBot â–¡ (_ +1) â†ª â–¡
with insertBot ($l0 â¸¬ $l) 0 â†ª (âŠ¥ â¸¬ ($l0 â¸¬ $l))
with insertBot ($l0 â¸¬ $l) ($n +1) â†ª $l0 â¸¬ (insertBot $l $n);

symbol insertBots : ğ•ƒ o â†’ ğ•ƒ nat â†’ ğ•ƒ o;
rule insertBots $l â–¡ â†ª $l
with insertBots $l ($n â¸¬ $nl) â†ª insertBots (insertBot $l $n) $nl;

// Theorems

opaque symbol deleteBot (n : â„•) (c: ğ•ƒ o) :
Ï€ (disj (insertBot c n) = disj c)â‰”
begin
    induction
        {induction
            {reflexivity}
            {assume x xlist h0; 
            simplify; 
            rewrite disj_correct; 
            rewrite âŠ¥âˆ¨; 
            reflexivity}} 
        {assume n h0; 
        induction
            {reflexivity}
            {assume x c;
            simplify;
            assume h1;
            rewrite disj_correct;
            rewrite disj_correct;
            rewrite (h0 c);
            reflexivity}}
end;

opaque symbol deleteBots (n : ğ•ƒ nat) (c: ğ•ƒ o):
Ï€ (disj (insertBots c n) = disj c)â‰”
begin
    induction
        {induction
            {reflexivity}
            {assume x xlist h0; 
            reflexivity}}
        {induction
            {assume n h0 c; 
            simplify; 
            rewrite left deleteBot 0 c; 
            rewrite left h0 (insertBot c 0); 
            reflexivity}
            {assume n h0 nlist h1 c; 
            rewrite left (deleteBot (n +1) c); 
            rewrite left h1 (insertBot c (n +1)); 
            reflexivity;}}
end;

// Application Example

assert a b c âŠ¢ deleteBots (0 â¸¬ 3 â¸¬ â–¡) (a â¸¬ b â¸¬ c â¸¬ â–¡) : 
    Ï€ ((âŠ¥ âˆ¨ a âˆ¨ b âˆ¨ âŠ¥ âˆ¨ c) = (a âˆ¨ b âˆ¨ c));

/******************************************************************************
*  N-ary Transform Theorem
******************************************************************************/

// Theorem

opaque symbol transform_n [l : Ï„ o] (c0 c1 c2: ğ•ƒ o): 
Ï€ (l â‡’ disj c1) â†’ Ï€ (disj (c0 ++ (l â¸¬ c2))) â†’ Ï€ (disj (c0 ++ c1 ++ c2)) â‰”
begin
    assume l c0 c1 c2 h2 h3;
    rewrite disj_++_correct;
    have H0: Ï€ ((disj c0) âˆ¨ disj (l â¸¬ c2))
        {rewrite left disj_++_correct; refine h3};
    refine âˆ¨â‚‘ H0 _ _
        {assume h4; refine âˆ¨áµ¢â‚ h4}
        {assume h4;
         have H1: Ï€ (l âˆ¨ disj c2)
            {rewrite left disj_correct; refine h4};
        rewrite disj_++_correct;
        refine âˆ¨â‚‘ H1 _ _
            {assume h5;
            refine âˆ¨áµ¢â‚‚ (âˆ¨áµ¢â‚ (h2 h5))}
            {assume h5;
            refine âˆ¨áµ¢â‚‚ (âˆ¨áµ¢â‚‚ h5)}}
end;

// Application Example

assert l0 l1 l2 l3 l1' l1'' âŠ¢ transform_n [l1] (l0 â¸¬ â–¡) (l1' â¸¬ l1'' â¸¬ â–¡) (l2 â¸¬ l3 â¸¬ â–¡): 
    (Ï€ (l1 â‡’ (l1' âˆ¨ l1''))) â†’  Ï€ (l0 âˆ¨ l1 âˆ¨ l2 âˆ¨ l3) â†’ Ï€ (l0 âˆ¨ l1' âˆ¨ l1'' âˆ¨ l2 âˆ¨ l3);